#!/usr/bin/env bash

set -e -u -o pipefail

source ci/includes/os.sh

TARGETS="//..."
EXCLUDED_TARGETS=""

# NOTE: We need to set the 'MSYS_ARG_CONV_EXCL' environment variable in various places, because
# otherwise on Windows, MSYS2 does weird things with Bazel target paths (see
# http://www.mingw.org/wiki/Posix_path_conversion).
export MSYS2_ARG_CONV_EXCL="//..."

# Function to join arrays with a specified string.
# Taken from: https://stackoverflow.com/questions/1527049/how-can-i-join-elements-of-an-array-in-bash#comment37571340_17841619
function joinBy { perl -e '$s = shift @ARGV; print join($s, @ARGV);' "$@"; }

function clangFormatLocation() {
  local CLANG_FORMAT_VERSION=10.0.0
  # Use find to get the path for either clang-format (macOS / Linux) or clang-format.exe (Windows)
  local CLANG_FORMAT_EXE=clang-format
  local CLANG_FORMAT_SHIM=clang-format
  if isWindows; then
    CLANG_FORMAT_EXE=clang-format.exe
  fi

  CLANG_FORMAT_VERSION_CALL="$("${CLANG_FORMAT_SHIM}" -version)" # Ensures that the binary is downloaded.

  local CLANG_FORMAT=CLANG_FORMAT_EXE
  if [[ ${CLANG_FORMAT} == "" ]]; then
    echo "ERROR: could not locate clang-format"
    echo "clang-format -version: ${CLANG_FORMAT_VERSION_CALL}"
    echo "which clang-format: $(which clang-format)"
    exit 1
  fi
  echo "${CLANG_FORMAT}"
}

# Generates a string of the form `<target to build>... -<target to exclude>...`
function generateBuildTargetString() {
  TARGET_STRING="${TARGETS}"

  # Append target exclusions only if there are excluded targets.
  if ! [[ -z "${EXCLUDED_TARGETS}" ]]; then
    TARGET_STRING="${TARGET_STRING} -$(joinBy " -" ${EXCLUDED_TARGETS})"
  fi

  echo "${TARGET_STRING}"
}

# Generates a string of the form `<target to build> [union <target to build>]* except (<target to exclude> [union <target to exclude>]*)`
# i.e. worker_sdk/... union applications except (worker_sdk/common:some_target union worker_sdk/common:some_other_target)
function generateAqueryTargetString() {
  TARGET_STRING="$(joinBy " union " ${TARGETS})"

  # Append target exclusions only if there are excluded targets.
  if ! [[ -z "${EXCLUDED_TARGETS}" ]]; then
    TARGET_STRING="${TARGET_STRING} except ($(joinBy " union " ${EXCLUDED_TARGETS}))"
  fi

  echo "${TARGET_STRING}"
}

function bazelLintTest() {
  # Use bazel to create patch files for all eligible source files.
  # Fail if any of the patch files are non-empty (i.e. lint was detected).
  CLANG_FORMAT="$(clangFormatLocation)" bazel build --config lint --output_groups=clang_format_test -- $(generateBuildTargetString)
}

function bazelLintFix() {
  # Use bazel to create patch files for all eligible source files.
  CLANG_FORMAT="$(clangFormatLocation)" bazel build --config lint --output_groups=clang_format_patches_only -- $(generateBuildTargetString)

  # Find bazel-bin prefix.
  BAZEL_BIN=$(bazel info bazel-bin)
  # I.e. on Linux, this is `bazel-out/k8-gcc-opt/bin`.
  PREFIX=${BAZEL_BIN#$(bazel info execution_root)/}

  # Use aquery to get the list of output files of the `CreatePatch` action,
  # Then strip the patch path down to that of its source file, and apply
  # the patch file generated by Bazel to the original source file.
  CLANG_FORMAT="$(clangFormatLocation)" bazel aquery --config lint --include_aspects --output_groups clang_format_patches_only "mnemonic(\"CreatePatch\", $(generateAqueryTargetString))" --output textproto \
    `# Get relative paths to source files` \
    `# perl used instead of grep --perl-regexp since grep macOS doesnt support it` \
    | perl -ne "while(/(?<=exec_path: \"${PREFIX//\//\\/}\/).*\.patch_.+(?=\")/g){print \"\$&\n\";}" \
    `# Create the patch commands which, when executed patch the source files.` \
    `# --binary flag used to correctly handle line endings on Windows.` \
    | xargs -L1 -I 'PATH_TO_SOURCE_FILE' echo 'FILE_PATH="PATH_TO_SOURCE_FILE"; echo patch --binary "${FILE_PATH%.patch_*}" "'${BAZEL_BIN}'/${FILE_PATH}"' \
    `# De-duplicate the patch commands, such that there is at most one patch command for each source file.` \
    `# There are N patch files per source files, where N is the number of bazel targets directly including the target.` \
    `# The format of the commands being de-duplicated is: patch --binary -source file- -patch file-` \
     | sh `# Calls the echo command generated by xargs, resulting in the patch command to be run by the next sh invocation below`\
     | sort --unique --field-separator=" " --key=3,3  `# Remove duplicate patch commands to the same source file` \
     | sh `# Execute patch commands`
}

MAYBEARG='-mode=check'
if [ $# -eq 1 ]; then
  if [ "$1" = "-fix" ]; then
    MAYBEARG=''
  fi
fi

if [[ -z "$MAYBEARG" ]]; then
  echo -e "\033[0;34mAttempting to fix linting errors automatically as '-fix' is specified.\033[0m"
  bazelLintFix
elif bazelLintTest; then
  echo -e "\033[0;32mAll source files passed clang-format linting check.\033[0m"
else
  echo -e "\033[0;31mThe above listed source file(s) didn't pass the clang-format linting check!\033[0m"
  echo -e "\033[0;34mYou can run 'ci/linting/clang-format.sh -fix' to fix them automatically.\033[0m"
  exit 1
fi
